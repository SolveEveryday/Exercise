# 최단 경로 알고리즘
## 뭐를 써야 할까?
* 가중치 없으면 BFS
* 가중치 있으면 다익스트라
* 가중치가 음수도 될 수 있다면 벨만-포드
* 모든 정점 쌍에 대한 최단경로라면 플로이드-와샬

## BFS
* 정점 A에서 BFS를 시작해서 B에 닿기까지의 깊이가 곧 최단거리

### 구현
0. distance[]를 둔다. distance[i]는 정점 A로부터 정점 i까지의 깊이를 담는다
	* 아직 방문하지 않았으면 -1로 두는 식으로 visited 역할도 함
1. 큐에 정점 A를 push 한다
2. 큐가 빌 때까지 아래를 반복한다
	1. 큐에서 정점을 꺼낸다
	2. 인접 정점 중 아직 방문 안한 정점이 있다면
		1. 현재 깊이 + 1을 그 정점의 깊이로 정해주고
		2. 큐에 해당 정점을 넣는다
* distance[i]는 정점 A-정점 i의 최단 거리
	* 원하면 B에 도달했을때 바로 return 등으로 나가도 됨

## 다익스트라
* 모든 정점들을 방문하며 시작 정점으로부터의 최단 거리를 구한다
* ‘바로 정점 Z를 갔을 때’와 ‘다른 우회경로로 Z를 갔을 때’를 비교해 더 적은 값을 구하는 게 핵심
* 여러 작은 경로의 최단거리가 모여서 큰 경로의 최단거리를 만든다는 점에서 다이나믹 프로그래밍을 활용한 알고리즘으로 볼 수 있다
* 우선순위 큐를 사용하면 더 시간 효율적으로 구현할 수 있다.

### 구현 (우선순위 큐)
0. distance[]를 둔다. distance[i]는 정점 A로부터 정점 i까지의 깊이를 담는다. 자기 자신까지의 거리는 0으로, 나머지 정점까지의 거리는 무한대로 초기화한다. 또, 기준을 가중치 값으로 하는 우선순위 큐를 만들어둔다. 한 아이템은 [도착 정점번호, 가중치]의 쌍이다. 자기 자신에게 도착하는 가중치를 0으로 집어넣어 둔다.
1. 우선순위 큐가 빌때까지 아래를 반복한다
	1. 큐에서 한 쌍을 꺼낸다. 각각 node, weight로 칭하겠다
	2. distance[꺼낸 정점 번호]보다 weight가 더 작을때만 아래를 수행한다
		1. 꺼낸 정점의 인접노드를 살펴보면서
		2. weight + 인접노드의 weight < distance[인접노드] 일 경우 우선순위 큐에 이 인접노드와 더 작아진 가중치 값을 넣는다.
